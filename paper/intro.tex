
\section{Introduction}
\label{sec:intro}

The Non-Uniform Memory Access (NUMA) architecture is an appealing solution for the scalability of multi-core era. Compared to Uniform Memory Access (UMA) architecture, the NUMA architecture avoids the bottleneck of a central memory controller: each processor (also known as a domain or node) consists of multiple cores, while each node can access its own memory controller. Different nodes are connected via high-speed inter-connection (such as Quick Path Interconnect (QPI)~\cite{intelqpi} or HyperTransport bus~\cite{hypertransport}) to form a cache-coherent system that presents an abstraction of a single globally addressable memory. 
However, NUMA applications may have serious performance issues, if programs have one of the following issues, such as large amount of remote accesses, load imbalance, contention for interconnection and last level cache~\cite{Blagodurov:2011:CNC:2002181.2002182, Dashti:2013:TMH:2451116.2451157}, as discussed more in Section~\ref{sec:overview}. 

Multiple types of approaches help improve the performance of NUMA systems. The first type of approaches migrates tasks or physical pages reactively based on memory access patterns or other hardware characteristics~\cite{Blagodurov:2011:CNC:2002181.2002182, AutoNUMA, Dashti:2013:TMH:2451116.2451157, Lepers:2015:TMP:2813767.2813788}. They improve the performance automatically without human involvement. However, these systems impose additional overhead (sometimes unnecessarily)  by migrating tasks or physical pages reactively. Further, the migration cannot reduce remote accesses if objects of the same page are concurrently accessed by multiple threads~\cite{Gaud:2014:LPM:2643634.2643659}. 
The second type of approaches relies on programmers to manage memory allocations and task assignments explicitly~\cite{Kaestle:2015:SSA:2813767.2813787, Lin:2016:MTP:2872362.2872401, Majo:2017:LPC:3057718.3040222}. Although they could improve the performance greatly, they typically require significant human effort to rewrite the programs, where legacy systems cannot benefit automatically. 

Another type of approach focuses on heap management~\cite{tcmallocnew, kim2013node, yang2019jarena}. The NUMA-aware memory management is appealing, because there is no need to change applications explicitly. Also, they are belonging to proactive approaches that could avoid some remote accesses without task or page migration. Among them, Kaminski et al. designs the first NUNA-aware memory allocator~\cite{tcmallocnew}, called as TcMalloc-NUMA in the remainder of this paper, where the other two papers utilize a similar approach. TcMalloc-NUMA invokes the \texttt{mbind} system call to bind the memory explicitly to the node that a thread is running on. That is, it can guarantee that 
%Due to the explicit binding, it is able to check the locality of a memory block inside the user space, and then return a freed object back to the corresponding node based on the locality. TcMalloc-NUMA achieves some performance speedup for some synthetic applications. 

However, TcMalloc-NUMA has multiple design issues. First, it always allocates the memory from the node that the thread is currently running on. But it may cause significant performance issue, when a thread is moving to a new node. For instance, a thread is forced to access its remote stack, and will lose the locality of cache lines. Further, this design is not tapped with the OS scheduler. As observed by previous study~\cite{Grace}, the OS scheduler typically assigns newly-created threads into the same processor as the parent thread to exploit cache locality. But all pages allocated in the original node will be remote accesses after the migration.  Second, it does not consider the load balance issue. As observed by existing NUMA profilers, many performance issues are related to shared objects that are allocated in the main thread but accessed concurrently by multiple children threads~\cite{XULIU, MemProf}. TcMalloc-NUMA will allocate such objects from the node that the main thread is running on, causing the load balance issue. Third, it does not employ the recent progress of the hardware and OS support, such as huge pages, due to its development in 2012. Fourth, its memory management cannot ensure the locality, if an object is deallocated by a thread that is different from the allocating thread. Fur such objects, \TN{} will simply place them into the local cache of the current thread. But this will generate unnecessary remote accesses, if the deallocation thread is located in a different node from its allocation thread.  


\begin{comment}

It first assumes that a memory block is belong to the same node for its allocating thread. However, this assumption is invalid, and is also contradict with the first-touch policy of the OS. 

If there is no such assumption, we will expect that the OS will provide an efficient API to query the locality of a page. However, no such APIs exist in both Linux and Windows. 

It checks the physical memory usage to determine the future allocations of the same node or the re-use of a remote node. But that is very slow by checking meminfo. 

In the end, it utilizes the mbind to bind the memory to a node specifically. 
	
\end{comment}
	 

%Based on our evaluation, TcMalloc-NUMA cannot achieve good performance for many applications.  
%However, none of these systems could achieve the performance promised by the hardware. Given a simple example, if one page is fulled with objects that are utilized by different threads running on different nodes, then it is not able to achieve the best performance no matter where this page is located. Similarly, the passive tracking of memory ownership of an object cannot completely avoid the ownership drifting problem, where the . 

This paper proposes a novel NUMA-aware memory allocator -- \NM{} -- to address these  issues. \NM{} improves both load balance and locality with the following designs.  

First, \NM{} proposes a \textbf{binding-based memory management policy} that ensures both load balance and locality. For load balance, \NM{} binds threads to different NUMA nodes in an interleaved way. That is, a newly -created thread will be always bound to a different node from its predecessor. Because of this binding policy, every node will have the similar number of threads, ensuring the load balance. Also, a thread will not be migrated to a different node due to the binding, avoiding the performance loss caused by cross-node thread migration. For the locality, \NM{} reserves a range of virtual memory for each node, where all physical pages can be only allocated from this node (specified via \texttt{mbind} system call). For each thread, an allocation can be only satisfied from its per-node heap, or from a per-thread cache that always tracked freed objects originated from the same node. More specifically, \NM{} checks the node locality of an object upon deallocations, and only places an object into its per-thread cache if it is originated from the same node, which is different from \TN{}. Otherwise, the object will be returned to its original node. \NM{} also reduces locality issues caused by metadata, by always allocating the metadata from the local node.  


% task management altogether, by binding tasks to different NUMA nodes interleavedly and binding the memory explicitly. The task binding not only benefits the load balance, due to its even distribution of tasks, but also constructs the basis for its memory management. In this design, there is no need to query the locality of tasks dynamically, and it is guaranteed to have the correct locality for the memory. 
  
Second, \NM{} further proposes \textbf{an interleaved heap} to reduce the load imbalance issue. More specifically, \NM{} reserves a range of virtual memory that physical pages will be allocated interleavedly across all physical nodes. That is,  physical pages from the interleaved heap will be evenly allocated from all nodes, avoiding the congestion of one memory controller~\cite{Blagodurov:2011:CNC:2002181.2002182}. However, a naive method of allocating all objects from the interleaved heap may actually cause unnecessary remote accesses. For instance, a private object should be always allocated in the local node, instead of from the interleaved heap (possibly from a remote node). \NM{} only allocates potentially-shared objects from the interleaved heap, and proposes a heuristics method to determine shared objects, as described in Section~\ref{sec:mainthread}.  

 Third, \NM{} also employs the recent progress of the hardware and the OS, such as huge page support. Note that this is different from the default support of transparent huge page. As observed by existing study~\cite{Gaud:2014:LPM:2643634.2643659, DBLP:conf/asplos/PanwarBG19}, the transparent huge page mechanism has a harmful impact on the performance for the NUMA architecture, due to memory waste and page-level false sharing. Differently, \NM{} only utilizes huge pages for big objects and small objects that are allocated extensively. \NM{}'s huge page support minimizes both memory waste and page-level false sharing. Based on our evaluation, \NM{}'s huge page support is always benefiting the performance (Section~\ref{sec:hugepage}). 
 
 Besides that, \NM{} is implemented very carefully in order to achieve the good performance. It introduces many implementation techniques, such as fast metadata lookup, cache warmup mechanism, efficient objects migration, node-local metadata, as further described in Section~\ref{sec:implement}. 
 
% Second, it proactively bound the memory to different nodes, so that it could reduce the . Third, it takes a different method to deal with allocations from main thread, Fourth, it takes the advantage of hardware progress automatically, e.g., huge pages. One application achieves 10\% performance speedup with this consideration.  


%There are other implementation issues that may also contribute to the performance improvement. For instance, the metadata will be always allocated locally. The big objects will be re-utilized by small objects automatically, in order to reduce the potential cache misses. 

We have performed extensive evaluation on synthetic and real applications, and compare \NM{} with popular allocators, such as the default Linux allocator, TcMalloc~\cite{tcmalloc}, jemalloc~\cite{jemalloc}, Intel TBB~\cite{tbb}, and Scalloc~\cite{Scalloc}. For the performance on real applications, \NM{} achieves around 13\% speedup on average comparing to the default Linux allocator, which is also 11\% faster than the second best one. For the \texttt{fluidanimate} application, \NM{} achieves up to $5.8\times$ faster than the default allocator, and $4.7\times$ faster than the second best one (TcMalloc). For four synthetic applications, \NM{} is running around $2.2\times$ faster than the second best one on an 8-node machine. In total, \NM{} may impose around 23\% memory overhead, but is much more scalable than all other allocators.  \NM{} is ready for the practical employment, due to its high performance, and good scalability. 

Overall, this paper has the following contributions. 

\begin{itemize}
\item \NM{} proposes a binding-based memory management that integrates task management with memory management together. This design ensures both load balance and locality.  
\item \NM{} proposes an interleaved heap in order to reduce load imbalance issue caused by shared objects. 
\item \NM{} proposes a new huge page support that can minimize memory waste and avoid page-level false sharing, which always benefiting the performance. 
\item \NM{} includes a large number of careful designs to reduce the performance and memory overhead. 
\item The extensive experiments confirm that \NM{} has a better performance and scalability than even widely-used industrial allocators. 
\end{itemize}

The remainder of this paper is organized as follows. Section~\ref{sec:overview} introduces some background, such as the NUMA architecture and the OS support. Section~\ref{sec:implement} focuses on the design and implementation of \NM{}. After that, Section~\ref{sec:evaluation} describes its experimentation evaluation, and Section~\ref{sec:limit} discusses the limitation of \NM{}. In the end, Section\ref{sec:related} discusses some relevant related work, and then Section~\ref{sec:conclusion} concludes. 

\begin{comment}

eve have evaluated it on a range of benchmarks and real applications on two different NUMA architecture. The evaluation showed that \NA{} could significant improve the performance by up to 2X, with the average of 10\% performance. The evaluation also show that \NA{} has a bigger performance improvement on  


 
How to design the new allocator? This is the new one. 

We will try to achieve the following target. 

(1) The performance will be as efficient as possible. 
(2) It is still 
For information-computable, we will achieve the following targets:
We should still use the address to infer the following information, such as the size of the object and the shadow memory placement.

We don't support many bags for the same size class, just one big bag for each size class of each heap. Why it is necessary? 

We would like to reduce the memory blowup as much as possible, where the memory will be returned back to the current thread's heap. 

In order to support that, maybe we could have a big heap for the same size class, but different threads will start from different placement. 

Is it good for the NUMA support in the future? For NUMA support, it is great if we can always return the memory back to its original 


Virtual address will be divided into multiple nodes. 

Then inside each step, we will divide a sub-heap into multiple mini-heaps, where each mini-heap will support one thread. 


Virtual address will be divided into multiple nodes. 

Then inside each per-node heap, we will further divide it into multiple mini-heaps, where each mini-heap will support one thread in order to reduce the possible contention. 

For each per-thread heap, we will have two free-lists for each size class. The first one will be used for the current thread, without the use of lock at all. The second one will be utilized for returning memory from other threads.  

RTDSCP is a way to know where a thread is executed on. 

%https://software.intel.com/en-us/forums/intel-isa-extensions/topic/280440

Should we put the metadata into the corresponding node? We will minimize the lock uses for each node, since that will invoke unnecessary remote accesses as well. 


% From Score: SCOREs runtime system will include a memory manager instrumented to track object ownership with low overhead by leveraging existing thread-local allocation buffers and using per-processor memory pools. The runtime system will sample memory access patterns to detect when memory should be relocated to or initially placed in memory closer to a specific processor

What is the uniqueness of NUMA architecture? 

Remote accesses and imbalance? 
What are the big issues that could cause the performance issues on the NUMA architecture. 

Programs also have some inherent imbalance. For instance, main thread typically will prepare the data for all children threads. Therefore, many existing tools discover that the block-wised allocation is one way to reduce the imbalance~\cite{XuNuma, XXX}. 
Also, many applications are typically utilizes a producer-consumer architecture, where the objects allocated in one thread will be deallocated by another thread. This issue, if not handle correctly, will cause the ownership thrifting issues, which will cause that it is impossible to know the placement of an object after a while. Very quickly, it may cause a lot of unnecessary remote accesses, when using the existing NUMA allocator~\cite{}.  

Therefore, a good NUMA allocator should deal with these inherent imbalance of programs. Also, it should deal with the normal problems of NUMA hardware. It should 
	
\subsection{Novelty}

\begin{itemize}
\item We will design a node-aware memory allocator that could actually identify the memory placement by using the virtual address.
\item We will minimize the synchronization, since that will impose unnecessary remote accesses. 
\item We will minimize remote accesses by putting the metadata into multiple nodes. 
\item We may support multiple types of allocation, such as block-wise false sharing memory accesses, or node-balanced memory accesses, relying on the indication from user space. 	
\item We will balance the memory consumption over all nodes, in order to avoid the contention of memory controller~\cite{Majo:2011:MSP:1987816.1987832}.  At least, we could balance the memory consumption among all allocators. Ideally, it is better to balance the memory accesses. 
\item We may track the relationship of all objects. Then those objects will be allocated correspondingly. For instance, if the objects are allocated in the main thread, we assume that they will be accessed as a shared mode. Then we would like to allocate in the node-balanced areana initially. 

\end{itemize}

\end{comment}


\begin{comment}


\begin{enumerate}
\item Dividing each node's memory into two parts, one for small objects, and one for big objects. 
\item Making the main thread to use a dedicate memory region. Memory will be allocated in different nodes in an interleaved way. However, this method has some benefits and shortcomings. If the memory is deallocated immediately, then it is time-consuming to put it remotely, and will hurt the performance. Therefore, it is necessary to identify such cases, and do not allocate such objects in the interleaved way. 
\item Fixing the merge and split for big objects
\item Thinking about the integration of Ding Chen's theory. (Let Xin to do this part)
\item Thinking about using the inside of the object for holding the pointers for link list, which will be faster and remove some memory overhead unnecessarily. (Let Xin to do this part)
\item For producer-consumer threads, we will also track which objects are allocated and freed in different threads. For those objects, maybe they could utilize the same mechanism as the main thread. But we will do this in the future.
%\item Could we use page-spans instead to ensure the sharing? 
\item Intercepting mmap and use the mainthread's interleaved idea. 

\item We will use huge pages by default in order to improve the performance. But we will utilize small bags for small size classes, which we will learn from TcMalloc. That is, we don't want to use 1 Megabyte information. Instead, we may utilize the 4 pages as an unit. 

	
\end{enumerate}
	
\end{comment}

