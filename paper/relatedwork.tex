\section{Related Work}

\label{sec:related}

This section discusses some related work with \NM{}. 

\paragraph{General Purpose Allocators:}
 There exists a large number of allocators~\cite{dlmalloc,Hoard,tcmalloc,jemalloc,Scalloc}, but they are not designed for NUMA architecture. Based on the management of small objects, allocators can be further classified into multiple types, such as sequential, BiBOP, and region-based allocators~\cite{Gay:1998:MME:277650.277748,  DieHarder}. Region-based allocators are suitable for special situations where all allocated objects within the same region can be deallocated at once~\cite{Gay:1998:MME:277650.277748}. For sequential allocators, subsequent memory allocations are satisfied in the continuous memory area, such as the Linux allocator originated from dlmalloc~\cite{dlmalloc} and Windows allocator~\cite{DieHarder}. That is, objects with different sizes can be placed continuously. For BiBOP-style allocators, one or multiple continuous pages are treated as a ``bag'', holding objects with the same size class. Many performance-oriented allocators, such as TCMalloc~\cite{tcmalloc}, \texttt{jemalloc}~\cite{jemalloc}, Hord~\cite{Hoard}, Scalloc~\cite{Scalloc}, and most secure allocators, such as OpenBSD~\cite{OpenBSD} and DieHarder~\cite{DieHarder}, belong to this type.  \NM{} also belongs to BiBOP-style allocators, and proposes multiple designs for the NUMA architecture. 

\paragraph{NUMA-aware Allocators:} TcMalloc-NUMA adds additional node-based freelists and free spans to store freed objects and pages belonging to the same node~\cite{tcmallocnew}, which is similar to \NM{}. It also invokes the \texttt{mbind} system call to bind physical memory allocations to the node that the current thread is running on. However, it does not support huge pages and interleaved heap, invokes too many \texttt{mbind} system calls, and does not handle the metadata's locality. nMART proposes a NUMA-aware memory allocation for soft real-time system~\cite{kim2013node}. It proposes node-oriented allocation policy to minimize the access latency, and ensures temporal and spatial guarantee for real-time systems. nMART requires the change of the underlying OS, which is different from \NM{}. nMART also has a different target as \NM{} that tries to meet the time requirement of real-time systems, and \NM{} focuses more on the performance.

\paragraph{NUMA-Aware Java Heap Management:} Some approaches that focus on improving the performance for Java applications, but they are not general purpose memory allocators. Ogasawara et. al. focus on finding the preferred node location for JAVA objects during the garbage collection and memory allocations~\cite{Ogasawara:2009:NMM:1640089.1640117}, via thread stack, synchronization information, and object reference graph. Tikir et. al. propose to employ hardware performance counters to collect the runtime information of Java applications, and then migrate objects to the closet node with most accesses~\cite{1419934}. 
NumaGiC reduces remote accesses in garbage collection phases with a mostly-distributed design that each GC thread will mostly collect memory references locally, and utilize a work-stealing mode only when no local references are available~\cite{NumaGiC}.


\paragraph{Combination of Task Scheduling and Memory Management:} 
Majo et. al. proposes to consider both data locality and cache contention, and combine memory management with task scheduling to achieve better performance~\cite{Majo:2011:MMN:1993478.1993481}. Memarzia et. al. observed that dynamic memory allocations, thread placement and scheduling, memory placement policies, OS configurations may help improve the query performance of in-memory databases~\cite{wagle2015numa}.  Majo et. al. proposes to set task-to-thread affinity, and pin threads to specific cores to achieve a better performance~\cite{Majo:2015:LPC:2688500.2688509}.   Diener proposes a new kernel framework to combine the task management and memory management together to achieve the better performance\cite{diener2015automatic}.
They inspire the combination of task scheduling and memory management of \NM{}, but \NM{} is the first work that combine both together inside the memory allocator. 


\paragraph{Other NUMA-related Systems:}
Cantalupo et. al. proposes multiple APIs that allow users to manage their memory in fine granularity by combining with multiple existing system calls~\cite{cantalupo2015memkind}. However, they are not targeting for a general purpose allocator, since it requires programmers to manage the memory explicitly.  Majo et. al. proposes multiple source-code based  algorithmic changes in order to improve  data sharing and  memory access patterns for NUMA architectures~\cite{6704666}. XPV extends virtualization technique by considering NUMA-topology and extending virtualization to SRLs ~\cite{Bui:2019:EPV:3302424.3303960}.

