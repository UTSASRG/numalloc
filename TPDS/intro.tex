
\section{Introduction}
\label{sec:intro}

\todo{change TcMalloc to TCMalloc}

The Non-Uniform Memory Access (NUMA) architecture is a scalable hardware design for multi-core and multi-processor era. Compared to Uniform Memory Access (UMA) architecture, the NUMA architecture avoids the bottleneck of using one memory controller, where each node/processor can access its own memory controller concurrently. But the NUMA architecture imposes multiple system challenges for parallel applications, such as remote accesses, interconnect congestion, and node imbalance~\cite{Blagodurov:2011:CNC:2002181.2002182}. 
%For instance, the latency of remote accesses is typically double to that of local accesses. 
The memory allocator is one such component that could help solve these challenges.   

However, general-purpose memory allocators, such as dlmalloc~\cite{dlmalloc},  Hoard~\cite{Hoard}, TCMalloc~\cite{tcmalloc}, jemalloc~\cite{jemalloc}, SuperMalloc~\cite{supermalloc}, Scalloc~\cite{Scalloc}, and mimalloc~\cite{mimalloc}, were designed for symmetric multiprocessing machines, without  considering the heterogeneity of the underlying hardware~\cite{mimalloc}. As a result, they can not achieve a good performance, based on existing work~\cite{tcmallocnew, yang2019jarena} and our evaluation.

Some memory allocators support the NUMA architecture~\cite{tcmallocnew, kim2013node, yang2019jarena, mimalloc}, as further discussed in Section~\ref{sec:related}. Among them, Kaminski designs the first NUMA-aware memory allocator~\cite{tcmallocnew}, called as TCMalloc-NUMA in the remainder of this paper. TCMalloc-NUMA aims to reduce remote accesses, but without considering interconnect congestion and node imbalance that may also significantly affect the performance. In TCMalloc-NUMA, allocations will be satisfied from a per-thread heap first, and then the freelist of the current node. However, \textit{TCMalloc-NUMA has multiple issues that may significantly affect its effectiveness}. First, it did not control deallocations of objects. A freed object is always placed into the deallocating thread's local buffer, a mechanism originated from TcMalloc~\cite{tcmalloc}. However, if such an object is originated from a remote node, this clearly will cause unnecessary remote accesses. Second, it did not control the placement of threads: a thread can be migrated to a remote node upon synchronizations or system calls, which not only force this thread to access its stack remotely but also reload all data that are already in the cache of its original node.  Further, after the migration, all deallocated objects by this thread will be placed into the new node's freelist afterwards, causing unnecessary remote accesses. 

\textbf{This paper proposes a novel memory allocator -- \NM{} -- that considers both hardware heterogeneity and allocation/deallocation attributes, with its fine-grained memory management}. \NM{} not only deals with hardware heterogeneity, but also employs different policies for objects with different attributes, such as share-ability, allocation pattern, sizes, and origin. We proposes multiple mechanisms that improve both load balance and locality, as detailed in the following.   

%Simply integrating thread binding, heap interleaving and huge page does not guarantee good performance. Instead, carefully design is required to properly coordinate the thread scheduling, memory object allocation/deallocation and huge page management to achieve better performance.

We propose an \textbf{origin-based memory management} ensuring that memory allocations are always satisfied from the local node of the requesting thread (called ``\textbf{local allocations}''). Note that the origin-based memory management is significantly different from the first-touch policy~\cite{lameter2013numa}. Under the first touch policy, a physical page is allocated from the node where a process first touches a virtual page. However, the first-touch policy does not handle freed objects, which could still introduce significant remote accesses in multi-threaded environment.  
Instead, \textit{the origin-based mechanism will track the origin of each object, and return a freed object based on its origin:} a freed object will be placed into the deallocating thread's local buffer \textbf{only if} it is originated from the same node that the current thread is running on; otherwise, it will be returned to its original node. \textit{Second, \NM{} introduces an origin-computable design that the physical origin can be simply computed within constant time}, as further described in Section~\ref{sec:overview}. This is important to reduce the overhead of checking the origin of each object, especially for applications with extensive deallocations. 
\textit{Third, it further includes an origin-based allocation that will perform the allocations based on the origin of a thread, which node the thread is running on, in order to ensure local allocations}.  


We further propose two mechanisms to \textbf{reduce load imbalance among different NUMA nodes}, another major source of NUMA performance issues~\cite{Dashti:2013:TMH:2451116.2451157}. \textit{First, it introduces an interleaved heap that its physical pages are allocated from different physical nodes in an interleaved way, which reduces load imbalance for the initial node that the main thread is running on}. This is inspired by profiling tools~\cite{XULIU, MemProf}, which discovered that shared objects allocated in the initial thread are the most common source of performance degradation. Under the first-touch policy, all shared objects of the main thread will be allocated from the node of the main thread, while concurrent accesses from multiple children threads will make this node the performance bottleneck. 
Instead, potentially-shared objects of the main thread (and before creating children threads) will be allocated from the interleaved heap, which helps distribute concurrent accesses from children threads to all nodes. Note that we do not track the origin for these objects, where they will be added to the interleave heap upon deallocations. \textit{Second,  a node-balanced thread binding is further introduced to reduce load imbalance}. We argue that thread-binding is helpful for the NUMA architecture, since a cross-node migration will basically turn all previously-local accesses of a thread into remote ones, leading to the large performance degradation. But the thread-binding itself is not new, which may introduce multiple issues if not handled properly. For instance, it cannot conflict with the OS-initiated scheduling. \NM{} binds a thread to a specific node, but not to a particular core, which still allows the OS-initiated inside-node migration. 
%\NM{} obtains the relationship between cores and nodes via existing \texttt{NUMA} APIs. 
To reduce the imbalance, \NM{} binds threads to nodes in a round-robin way so that each node will have a similar number of threads, helping reduce the congestion of a particular memory controller~\cite{Blagodurov:2011:CNC:2002181.2002182}. Based on our knowledge, \NM{} is the first memory allocator that introduces node-balanced thread binding inside. 
%In the future, we plan to support user-controlled binding. 
%Due to the binding, \NM{} can  allocate the metadata of each thread (e.g., per-thread buffer) from the local node, which cannot be done without the binding. 

%in order to reduce load imbalance or interconnect congestion that occurs when a large amount of memory allocated in the initial thread are accessed extensively by children threads running on different nodes. 
%second, it may cause page-level false sharing, if a multi-page object is accessed concurrently by these threads, the most common NUMA performance detected by existing tools~\cite{XULIU, MemProf}. The underlying reason is that the first-touch policy makes objects allocated from the initial thread will be allocated from its corresponding node, as further described in Section~\ref{sec:ossupport}. The interleaved heap helps node balance, and alleviates page-level false sharing. 
 
\todo{\NM{} further introduces \textbf{selective huge pages} in order to exploit the benefit of huge pages. Huge pages will improve the performance if they are employed properly~\cite{DBLP:conf/asplos/MaasAIJMR20}, due to the reduction of TLB misses. However, the default transparent huge pages (THP) have been observed to hurt the performance on the NUMA architecture, due to unnecessary memory wastes and page-level false sharing~\cite{Gaud:2014:LPM:2643634.2643659, DBLP:conf/asplos/PanwarBG19, DBLP:conf/asplos/MaasAIJMR20}. \textit{\NM{} controls the type of objects that will be allocated from huge pages, in order to avoid the issues caused by huge pages}. In \NM{}, huge pages will be utilized only for big objects, as well as small objects with extensive allocations. This design is to reduce memory wastes. Based on our evaluation in Section~\ref{sec:hugepage}, \NM{} selective huge pages do not hurt the performance, compared to transparent huge pages. }
 
\NM{} also has some implementation challenges. Since \NM{} has many per-thread and per-node heaps, it is necessary to move freed objects between per-thread freelists and per-node freelists frequently. \NM{} designs an efficient mechanism to move objects between them, without traversing all objects in the freelists as TCMalloc~\cite{tcmalloc}.  It allocates the metadata of per-thread and per-node heap on the local nodes in order to further reduce unnecessary remote accesses.  

%It also reduces memory consumption of huge pages by making multiple threads share the same bag, overcoming one issue of Scalloc~\cite{Scalloc}. 

We have performed extensive evaluation on synthetic and real applications, and compared \NM{} with popular allocators, such as the default Linux allocator, TCMalloc~\cite{tcmalloc}, jemalloc~\cite{jemalloc}, Intel TBB~\cite{tbb}, Scalloc~\cite{Scalloc}, and mimalloc~\cite{mimalloc}. \NM{} achieves around 15\% speedup comparing to the default Linux allocator, which is also 12\% faster than the second-best one (e.g., TCMalloc). For the best case, \NM{} runs up to $6.4\times$ faster than the default allocator, and $4.6\times$ faster than the second-best one (TCMalloc). \NM{} is much more scalable than other allocators based on our evaluation. \NM{} is ready for practical employment, due to its high performance and good scalability. \\

\textbf{Overall, this paper makes the following contributions:} 

\begin{itemize}

\item It proposes a \textit{fine-grained memory management} method that will consider both hardware heterogeneity and different allocation/deallocation attributes in memory management operations.

\item It proposes an \textit{origin-based memory management} to ensure locality of all memory allocations,  \textit{the interleaved heap and node-balanced thread binding} to reduce node imbalance, and \textit{selective huge pages} to overcome the issues of transparent huge pages. 

\item It presents the development and implementation of \NM{}, which has a better performance and scalability than widely-used commercial allocators, such as TCMalloc, jemalloc, and Intel TBB. 

\end{itemize}

The remainder of this paper is organized as follows. Section~\ref{sec:overview} introduces the OS support for the NUMA architecture and common designs of memory allocators. Section~\ref{sec:implement} focuses on the design and implementation of \NM{}. After that, Section~\ref{sec:evaluation} describes its experimental evaluation, and Section~\ref{sec:limit} discusses the limitation of \NM{}. In the end, Section\ref{sec:related} discusses some relevant related work, and then Section~\ref{sec:conclusion} concludes. 

